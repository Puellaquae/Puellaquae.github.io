<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>正则表达式转化为自动机</title>
    <link rel="stylesheet" href="../css/luna.css" />
    <link rel="stylesheet" href="../css/codecolor.css" />
</head>

<body>
    <header class="header">
        <section sub="" class="navbar-left title">
            Puelloc
        </section>
        <section class="navbar-right">
            <a href="../index.html">首页</a>
            <a href="about.html">关于</a>
        </section>
    </header>
    <div class="container">
        <div class="archive">
            <h1>正则表达式转化为自动机</h1>

            <div class="modified date">
                2021/10/21
            </div>
            <div class="create date">
                2021/10/14
            </div>
            
            <div class="entry">
                <p>正则文法，3-型文法，可用正则表达式描述，可被有限状态自动机接受。</p>

<p>一般，正则表达式到 DFA 转化分为三步：</p>

<ul>
<li>正则表达式转化为 NFA</li>
<li>NFA 转化 DFA</li>
<li>DFA 最小化</li>
</ul>

<h2>正则表达式转化为 NFA</h2>

<h3>正则表达式的定义</h3>

<p>本文只实现了最基础的正则表达式，仅支持连接 <code>ab</code>，选择 <code>a|b</code> 和 Kleene 星号 <code>a*</code> 运算。此外，因为没有做字符转义，所以 ε 将被特殊符号处理。程序未考虑运算优先级，没有使用括号指明的都当作 UB 考虑。</p>

<h3>预处理正则表达式</h3>

<p>根据 <a href="https://swtch.com/~rsc/regexp/regexp1.html"><em>Regular Expression Matching Can Be Simple And Fast</em></a> 这篇文章。预先将正则表达式预处理为后缀表达式再转化到 NFA 更方便。对于省略的连接运算符，相邻两个字符，字符与括号，星号和字符之间都需要额外补上。例如 <code>aa(((bc)|(de))*)f</code> 补上省略的连接符（用加号表示）<code>a+a+(((b+c)|(d+e))*)+f</code>，转为后缀 <code>aabc+de+|*f+++</code>。</p>

<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">regex2post</span><span class="p">(</span><span class="n">r</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">RegexToken</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">RegexToken</span>::<span class="p">{</span><span class="n">Alter</span><span class="p">,</span><span class="w"> </span><span class="n">Cat</span><span class="p">,</span><span class="w"> </span><span class="n">Bracket</span><span class="p">,</span><span class="w"> </span><span class="n">Closure</span><span class="p">,</span><span class="w"> </span><span class="n">Char</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">post</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">add_cat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 表示是否需要一个连接符</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">chars</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="sc">&#39;|&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">add_cat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 新的双目运算符直接取代了连接符</span>
<span class="w">                </span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Alter</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="sc">&#39;(&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">add_cat</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Cat</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="n">add_cat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 一个左括号可以连接前面的，但不能连接后面的</span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Bracket</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="sc">&#39;)&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">add_cat</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">unreachable!</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="o">!</span><span class="fm">matches!</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">last</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Bracket</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">post</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="sc">&#39;*&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 单目运算符不影响状态</span>
<span class="w">                </span><span class="n">post</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Closure</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="sc">&#39;ε&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">add_cat</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Cat</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">add_cat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">post</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Epsilon</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">add_cat</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Cat</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">add_cat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// 字符即可连接前面也可连接后面</span>
<span class="w">                </span><span class="n">post</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Char</span><span class="p">(</span><span class="n">c</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">add_cat</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">unreachable!</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">post</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">r</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">post</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<h3>后缀表达式转 NFA</h3>

<p>rust 用指针不是很方便，所以这里用数组来存放 NFA 的图结构。</p>

<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">NFA</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">nodes</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">edges</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">start</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">out</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>用一个栈来存放后缀表达式转化到 NFA 中临时的图，使用边来表示（即想象将这个图的入口和出口用一条有向边直接连起来），暂且称之为块。</p>

<p>对于字符，直接向图中添加新节点，压入下标。</p>

<div class="codehilite"><pre><span></span><code><span class="n">RegexToken</span>::<span class="n">Char</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nfa</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">NFANode</span>::<span class="n">new</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)));</span><span class="w"></span>
<span class="w">    </span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">RegexToken</span>::<span class="n">Epsilon</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nfa</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">NFANode</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>对于连接符，弹出两个块，块甲和块乙（注意先后）。连接乙的出和甲的入（这条边是可以确定下来存入 NFA 中的），再压入乙的入和甲的出。</p>

<div class="codehilite"><pre><span></span><code>      +---+    +---+
in -&gt; | B | -&gt; | A | -&gt; out 
      +---+    +---+
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">RegexToken</span>::<span class="n">Cat</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">e2_start</span><span class="p">,</span><span class="w"> </span><span class="n">e2_out</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">e1_start</span><span class="p">,</span><span class="w"> </span><span class="n">e1_out</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">nfa</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e1_out</span><span class="p">,</span><span class="w"> </span><span class="n">e2_start</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">e1_start</span><span class="p">,</span><span class="w"> </span><span class="n">e2_out</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>对于选择符，弹出两个块，需要两个新节点做辅助，并可确定四条边。</p>

<div class="codehilite"><pre><span></span><code>              +---+
        +---&gt; | A | ---&gt;+
      +---+   +---+   +---+
in -&gt; |   |           |   | -&gt; out
      +---+   +---+   +---+
        +---&gt; | B | ---&gt;+
              +---+
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">RegexToken</span>::<span class="n">Alter</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">e2_start</span><span class="p">,</span><span class="w"> </span><span class="n">e2_out</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">e1_start</span><span class="p">,</span><span class="w"> </span><span class="n">e1_out</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nfa</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">NFANode</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nfa</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">NFANode</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">nfa</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">a_start</span><span class="p">,</span><span class="w"> </span><span class="n">e1_start</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">nfa</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">a_start</span><span class="p">,</span><span class="w"> </span><span class="n">e2_start</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">nfa</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e1_out</span><span class="p">,</span><span class="w"> </span><span class="n">a_out</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">nfa</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e2_out</span><span class="p">,</span><span class="w"> </span><span class="n">a_out</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">a_start</span><span class="p">,</span><span class="w"> </span><span class="n">a_out</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>对于星号，弹出一个块，需要一个新节点做辅助，并可确定两条边。</p>

<div class="codehilite"><pre><span></span><code>              +---+
        +---&gt; | A |
      +---+   +---+
in -&gt; |   | &lt;---+  
      +---+
        +---&gt; out
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">RegexToken</span>::<span class="n">Closure</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nfa</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">NFANode</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">e_start</span><span class="p">,</span><span class="w"> </span><span class="n">e_out</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">nfa</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="n">e_start</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">nfa</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e_out</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>最后栈里剩下的一个块就是完整的图了，两个下标分别就是 NFA 的初始状态和接收状态，后缀表达式到 NFA 的转化就做完了。</p>

<h2>NFA 转 DFA</h2>

<p>NFA 转 DFA 使用子集构造法，这需要为 NFA 增加一个 <code>get_reach</code> 函数计算一个状态消耗一个字符可到达的状态的集合。另外 DFA 没有采用 NFA 一样的数据结构，而是直接使用了一个二维数组表示。</p>

<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">DFA</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">accepts</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">table</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">start</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">out</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>以 <code>nfa.get_reach(nfa.start, None)</code> 作为初始状态，求新的状态，直到没有新的状态产生为止。所有包含了原终结状态的新状态都作为 DFA 的终结状态。</p>

<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">determinize</span><span class="p">(</span><span class="n">nfa</span>: <span class="kp">&amp;</span><span class="nc">NFA</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">DFA</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nfa</span><span class="p">.</span><span class="n">get_reach</span><span class="p">(</span><span class="n">nfa</span><span class="p">.</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="n">start</span><span class="p">.</span><span class="n">clone</span><span class="p">()];</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">accepts</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nfa</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">get_accepts</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="fm">matches!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">unwrap</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w"> </span><span class="c1">// 输入符号集合</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="o">!</span><span class="n">states</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">states</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">new_states</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accepts</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">a</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">new_state</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">nfa</span><span class="p">.</span><span class="n">get_reach</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)))</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">flatten</span><span class="p">()</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="n">new_state</span><span class="p">.</span><span class="n">sort_unstable</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="n">new_state</span><span class="p">.</span><span class="n">dedup</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="n">new_state</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">table</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">new_states</span><span class="p">.</span><span class="n">clone</span><span class="p">()));</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">new_state</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">new_states</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">new_state</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"></span>
<span class="w">                </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">table</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">any</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">new_state</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">states</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_state</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">states</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">new_state</span><span class="p">)</span><span class="w"> </span><span class="c1">// 只有新的状态才加入计算队列</span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">rename</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">enumerate</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="mf">0.</span><span class="n">clone</span><span class="p">(),</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">DFA</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">accepts</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">table</span>: <span class="nc">table</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">ns</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">ns</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">rename</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">).</span><span class="n">copied</span><span class="p">())</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">collect</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="n">start</span>: <span class="o">*</span><span class="n">rename</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">).</span><span class="n">unwrap</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span>: <span class="nc">rename</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfa</span><span class="p">.</span><span class="n">out</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">collect</span><span class="p">(),</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<h2>最小化 DFA</h2>

<p>最小化 DFA 使用的是 Hopcroft 算法，但是不同于网上算法，这里首先求出了状态的划分，再重新建立跳转表。划分状态首先要判断两个状态是否可区分（distinguish）,即能否有串能被甲状态接受而不被乙状态接受。如果甲、乙接受一个字符跳转到的状态丙、丁是可区分的，那么甲、乙是可区分的。根据定义，一个终结状态和一个非终结状态一定是可区分的（终结状态可接受 ε 而非终结状态不能）。由此可以递归地求出任意两个状态是否是可区分的。</p>

<p>例如：</p>

<div class="codehilite"><pre><span></span><code>   | a | b |
 0 | 2 | 1 |
 1 | 2 | 1 |
 2 | 2 | 1 |
</code></pre></div>

<p>其中 0 是初始状态，1 是终结状态。这里的 0 和 2 就是不可区分的两个状态，因为没有一个串可以被 0 接受而不被 2 接受。所以状态就被划分为 {0, 2} 和 1。</p>

<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">distinguishable</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">p</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">q</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="n">TransRes</span>::<span class="p">{</span><span class="n">Accept</span><span class="p">,</span><span class="w"> </span><span class="n">Next</span><span class="p">,</span><span class="w"> </span><span class="n">Unaccept</span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">p_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">q_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">p_out</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">q_out</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">accepts</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">accepts</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">a</span><span class="o">|</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">accepts</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">accepts</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_trans</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_trans</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">Accept</span><span class="p">,</span><span class="w"> </span><span class="n">Accept</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">Unaccept</span><span class="p">,</span><span class="w"> </span><span class="n">Unaccept</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">Accept</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">Accept</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">Unaccept</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">Unaccept</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">Next</span><span class="p">(</span><span class="n">rc</span><span class="p">),</span><span class="w"> </span><span class="n">Next</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">distinguishable</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span><span class="w"> </span><span class="n">sc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kc">false</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>得到了新的一组状态后，需要重建跳转表。因为多个原状态被合并为了一个新状态，所有只要求任意一个原状态的跳转就可得出新状态的跳转了。</p>

<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">minimize</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">DFA</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_nondistinguishable_states</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">rename</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">states</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">enumerate</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">tx</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)))</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">flatten</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">states</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">state_trans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">accepts</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">a</span><span class="o">|</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_trans</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">.</span><span class="n">first</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">TransRes</span>::<span class="n">Accept</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">unreachable!</span><span class="p">(),</span><span class="w"></span>
<span class="w">                    </span><span class="n">TransRes</span>::<span class="n">Next</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">*</span><span class="n">rename</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="p">).</span><span class="n">unwrap</span><span class="p">()),</span><span class="w"></span>
<span class="w">                    </span><span class="n">TransRes</span>::<span class="n">Unaccept</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="p">})</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">table</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">state_trans</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">DFA</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">accepts</span>: <span class="nc">self</span><span class="p">.</span><span class="n">accepts</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w"></span>
<span class="w">            </span><span class="n">table</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">start</span>: <span class="o">*</span><span class="n">rename</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">start</span><span class="p">).</span><span class="n">unwrap</span><span class="p">(),</span><span class="w"></span>
<span class="w">            </span><span class="n">out</span>: <span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">o</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">out</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="o">*</span><span class="n">rename</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">unwrap</span><span class="p">())</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="n">o</span><span class="p">.</span><span class="n">sort_unstable</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="n">o</span><span class="p">.</span><span class="n">dedup</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="n">o</span><span class="w"></span>
<span class="w">            </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div>

            </div>
        </div>
    </div>

    <div class="footer">
        <p rel="license"><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></p>
        <p rel="contact">
            <a href="mailto:shentukeqin@hotmail.com">Mail</a>
            <a href="https://github.com/Puellaquae">Github</a>
        </p>
    </div>
</body>

</html>