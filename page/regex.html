<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>正则表达式转化为自动机</title>
    <link rel="stylesheet" href="../css/style.css" />
    <link rel="stylesheet" href="../css/codecolor.css" />
</head>

<body>
    <header class="header">
        <section sub="" class="navbar-left title">
            Puelloc
        </section>
        <section class="navbar-right">
            <a href="../index.html">首页</a>
            <a href="about.html">关于</a>
        </section>
    </header>
    <div class="container">
        <div class="archive">
            <h1>正则表达式转化为自动机</h1>

            <div class="modified date">
                2021/11/27
            </div>
            <div class="create date">
                2021/11/27
            </div>
            
            <span class="meta">Rust</span>
            
            <span class="meta">Regex</span>
            
            <div class="entry">
                <p>正则文法，3-型文法，可用正则表达式描述，可被有限状态自动机接受。</p>

<p>一般，正则表达式到 DFA 转化分为三步：</p>

<ul>
<li>正则表达式转化为 NFA</li>
<li>NFA 转化 DFA</li>
<li>DFA 最小化</li>
</ul>

<h2>正则表达式转化为 NFA</h2>

<h3>正则表达式的定义</h3>

<p>本文只实现了最基础的正则表达式，仅支持连接 <code>ab</code>，选择 <code>a|b</code> 和 Kleene 星号 <code>a*</code> 运算。此外，因为没有做字符转义，所以 ε 将被特殊符号处理。程序未考虑运算优先级，没有使用括号指明的都当作 UB 考虑。</p>

<h3>预处理正则表达式</h3>

<p>根据 <a href="https://swtch.com/~rsc/regexp/regexp1.html"><em>Regular Expression Matching Can Be Simple And Fast</em></a> 这篇文章。预先将正则表达式预处理为后缀表达式再转化到 NFA 更方便。对于省略的连接运算符，相邻两个字符，字符与括号，星号和字符之间都需要额外补上。例如 <code>aa(((bc)|(de))*)f</code> 补上省略的连接符（用加号表示）<code>a+a+(((b+c)|(d+e))*)+f</code>，转为后缀 <code>aabc+de+|*f+++</code>。</p>

<pre><code>pub fn regex2post(r: &amp;str) -&gt; Vec&lt;RegexToken&gt; {
    use RegexToken::{Alter, Cat, Bracket, Closure, Char};
    let mut stack = Vec::new();
    let mut post = Vec::new();
    let mut add_cat = false; // 表示是否需要一个连接符
    for c in r.chars() {
        match c {
            '|' =&gt; {
                add_cat = false; // 新的双目运算符直接取代了连接符
                stack.push(Alter);
            }
            '(' =&gt; {
                if add_cat {
                    stack.push(Cat);
                    add_cat = false; // 一个左括号可以连接前面的，但不能连接后面的
                }
                stack.push(Bracket);
            }
            ')' =&gt; {
                if !add_cat { unreachable!(); }
                while !matches!(stack.last(), Some(Bracket) | None) {
                    post.push(stack.pop().unwrap());
                }
                stack.pop();
            }
            '*' =&gt; { // 单目运算符不影响状态
                post.push(Closure);
            }
            'ε' =&gt; {
                if add_cat {
                    stack.push(Cat);
                }
                add_cat = true;
                post.push(Epsilon);
            }
            _ =&gt; {
                if add_cat {
                    stack.push(Cat);
                }
                add_cat = true; // 字符即可连接前面也可连接后面
                post.push(Char(c));
            }
        }
    }
    if !add_cat { unreachable!(); }
    while let Some(r) = stack.pop() {
        post.push(r);
    }
    post
}
</code></pre>

<h3>后缀表达式转 NFA</h3>

<p>rust 用指针不是很方便，所以这里用数组来存放 NFA 的图结构。</p>

<pre><code>pub struct NFA {
    pub nodes: Vec&lt;Option&lt;char&gt;&gt;,
    pub edges: Vec&lt;(usize, usize)&gt;,
    pub start: usize,
    pub out: usize,
}
</code></pre>

<p>用一个栈来存放后缀表达式转化到 NFA 中临时的图，使用边来表示（即想象将这个图的入口和出口用一条有向边直接连起来），暂且称之为块。</p>

<p>对于字符，直接向图中添加新节点，压入下标。</p>

<pre><code>RegexToken::Char(c) =&gt; {
    let idx = nfa.add_node(NFANode::new(Some(*c)));
    stack.push((idx, idx));
}

RegexToken::Epsilon =&gt; {
    let idx = nfa.add_node(NFANode::new(None));
    stack.push((idx, idx));
}
</code></pre>

<p>对于连接符，弹出两个块，块甲和块乙（注意先后）。连接乙的出和甲的入（这条边是可以确定下来存入 NFA 中的），再压入乙的入和甲的出。</p>

<pre><code>      +---+    +---+
in -&gt; | B | -&gt; | A | -&gt; out 
      +---+    +---+
</code></pre>

<pre><code>RegexToken::Cat =&gt; {
    let (e2_start, e2_out) = stack.pop().unwrap();
    let (e1_start, e1_out) = stack.pop().unwrap();
    nfa.add_edge(e1_out, e2_start);
    stack.push((e1_start, e2_out));
}
</code></pre>

<p>对于选择符，弹出两个块，需要两个新节点做辅助，并可确定四条边。</p>

<pre><code>              +---+
        +---&gt; | A | ---&gt;+
      +---+   +---+   +---+
in -&gt; |   |           |   | -&gt; out
      +---+   +---+   +---+
        +---&gt; | B | ---&gt;+
              +---+
</code></pre>

<pre><code>RegexToken::Alter =&gt; {
    let (e2_start, e2_out) = stack.pop().unwrap();
    let (e1_start, e1_out) = stack.pop().unwrap();
    let a_start = nfa.add_node(NFANode::new(None));
    let a_out = nfa.add_node(NFANode::new(None));
    nfa.add_edge(a_start, e1_start);
    nfa.add_edge(a_start, e2_start);
    nfa.add_edge(e1_out, a_out);
    nfa.add_edge(e2_out, a_out);
    stack.push((a_start, a_out));
}
</code></pre>

<p>对于星号，弹出一个块，需要一个新节点做辅助，并可确定两条边。</p>

<pre><code>              +---+
        +---&gt; | A |
      +---+   +---+
in -&gt; |   | &lt;---+  
      +---+
        +---&gt; out
</code></pre>

<pre><code>RegexToken::Closure =&gt; {
    let idx = nfa.add_node(NFANode::new(None));
    let (e_start, e_out) = stack.pop().unwrap();
    nfa.add_edge(idx, e_start);
    nfa.add_edge(e_out, idx);
    stack.push((idx, idx));
}
</code></pre>

<p>最后栈里剩下的一个块就是完整的图了，两个下标分别就是 NFA 的初始状态和接收状态，后缀表达式到 NFA 的转化就做完了。</p>

<h2>NFA 转 DFA</h2>

<p>NFA 转 DFA 使用子集构造法，这需要为 NFA 增加一个 <code>get_reach</code> 函数计算一个状态消耗一个字符可到达的状态的集合。另外 DFA 没有采用 NFA 一样的数据结构，而是直接使用了一个二维数组表示。</p>

<pre><code>pub struct DFA {
    pub accepts: Vec&lt;char&gt;,
    pub table: Vec&lt;Vec&lt;Option&lt;usize&gt;&gt;&gt;,
    pub start: usize,
    pub out: Vec&lt;usize&gt;,
}
</code></pre>

<p>以 <code>nfa.get_reach(nfa.start, None)</code> 作为初始状态，求新的状态，直到没有新的状态产生为止。所有包含了原终结状态的新状态都作为 DFA 的终结状态。</p>

<pre><code>pub fn determinize(nfa: &amp;NFA) -&gt; DFA {
    let start = nfa.get_reach(nfa.start, None);
    let mut table = Vec::new();
    let mut states = vec![start.clone()];
    let accepts: Vec&lt;_&gt; = nfa
        .get_accepts()
        .into_iter()
        .filter(|x| matches!(x, Some(_)))
        .map(|x| x.unwrap())
        .collect(); // 输入符号集合
    while !states.is_empty() {
        let state = states.pop().unwrap();
        let new_states: Vec&lt;_&gt; = accepts
            .iter()
            .map(|a| {
                let mut new_state: Vec&lt;_&gt; = state
                    .iter()
                    .map(|s| nfa.get_reach(*s, Some(*a)))
                    .flatten()
                    .collect();
                new_state.sort_unstable();
                new_state.dedup();
                new_state
            })
            .collect();
        table.push((state, new_states.clone()));
        for new_state in new_states {
            if !new_state.is_empty()
                &amp;&amp; !table.iter().any(|s| s.0 == new_state)
                &amp;&amp; !states.contains(&amp;new_state)
            {
                states.push(new_state) // 只有新的状态才加入计算队列
            }
        }
    }

    let rename: HashMap&lt;Vec&lt;usize&gt;, usize&gt; = table
        .iter()
        .enumerate()
        .map(|(i, s)| (s.0.clone(), i))
        .collect();

    DFA {
        accepts,
        table: table
            .into_iter()
            .map(|(_, ns)| {
                ns.iter()
                    .map(|n| rename.get(n).copied())
                    .collect::&lt;Vec&lt;_&gt;&gt;()
            })
            .collect(),
        start: *rename.get(&amp;start).unwrap(),
        out: rename
            .into_iter()
            .filter(|(s, _)| s.contains(&amp;nfa.out))
            .map(|(_, i)| i)
            .collect(),
    }
}
</code></pre>

<h2>最小化 DFA</h2>

<p>最小化 DFA 使用的是 Hopcroft 算法，但是不同于网上算法，这里首先求出了状态的划分，再重新建立跳转表。划分状态首先要判断两个状态是否可区分（distinguish）,即能否有串能被甲状态接受而不被乙状态接受。如果甲、乙接受一个字符跳转到的状态丙、丁是可区分的，那么甲、乙是可区分的。根据定义，一个终结状态和一个非终结状态一定是可区分的（终结状态可接受 ε 而非终结状态不能）。由此可以递归地求出任意两个状态是否是可区分的。</p>

<p>例如：</p>

<pre><code>   | a | b |
 0 | 2 | 1 |
 1 | 2 | 1 |
 2 | 2 | 1 |
</code></pre>

<p>其中 0 是初始状态，1 是终结状态。这里的 0 和 2 就是不可区分的两个状态，因为没有一个串可以被 0 接受而不被 2 接受。所以状态就被划分为 {0, 2} 和 1。</p>

<pre><code>pub fn distinguishable(&amp;self, p: usize, q: usize) -&gt; bool {
        use TransRes::{Accept, Next, Unaccept};
        let p_out = self.out.contains(&amp;p);
        let q_out = self.out.contains(&amp;q);
        if p_out ^ q_out {
            return true;
        }
        if p == q {
            return false;
        }
        let mut accepts: Vec&lt;_&gt; = self.accepts
            .iter()
            .map(|a| Some(*a))
            .collect();
        accepts.push(None);
        for a in accepts {
            let r = self.get_trans(p, a);
            let s = self.get_trans(q, a);
            match (r, s) {
                (Accept, Accept) | (Unaccept, Unaccept) =&gt; {}
                (Accept, _) | (_, Accept) | (Unaccept, _) | (_, Unaccept) =&gt; {
                    return true;
                }
                (Next(rc), Next(sc)) =&gt; {
                    if self.distinguishable(rc, sc) {
                        return true;
                    }
                }
            }
        }
        false
    }
</code></pre>

<p>得到了新的一组状态后，需要重建跳转表。因为多个原状态被合并为了一个新状态，所有只要求任意一个原状态的跳转就可得出新状态的跳转了。</p>

<pre><code>pub fn minimize(&amp;self) -&gt; DFA {
        let states = self.get_nondistinguishable_states();
        let rename: HashMap&lt;usize, usize&gt; = states
            .iter()
            .enumerate()
            .map(|(i, x)| x.iter().map(move |tx| (*tx, i)))
            .flatten()
            .collect();
        let mut table = Vec::new();
        for s in states {
            let state_trans = self
                .accepts
                .iter()
                .map(|a| match self.get_trans(*s.first().unwrap(), Some(*a)) {
                    TransRes::Accept =&gt; unreachable!(),
                    TransRes::Next(ns) =&gt; Some(*rename.get(&amp;ns).unwrap()),
                    TransRes::Unaccept =&gt; None,
                })
                .collect::&lt;Vec&lt;_&gt;&gt;();
            table.push(state_trans);
        }
        DFA {
            accepts: self.accepts.clone(),
            table,
            start: *rename.get(&amp;self.start).unwrap(),
            out: {
                let mut o: Vec&lt;_&gt; = self.out
                    .iter()
                    .map(|x| *rename.get(x).unwrap())
                    .collect();
                o.sort_unstable();
                o.dedup();
                o
            },
        }
    }
</code></pre>

            </div>
        </div>
    </div>

    <div class="footer">
        <p rel="license"><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></p>
        <p rel="contact">
            <a href="mailto:shentukeqin@hotmail.com">Mail</a>
            <a href="https://github.com/Puellaquae">Github</a>
        </p>
    </div>
</body>

</html>